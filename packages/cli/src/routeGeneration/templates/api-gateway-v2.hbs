/* tslint:disable */
/* eslint-disable */
// WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file:
https://github.com/lukeautry/tsoa
import { Controller, ValidationService, FieldErrors, ValidateError, TsoaRoute } from '@jeremydavidson/tsoa';
{{#each controllers}}
// WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file:
https://github.com/lukeautry/tsoa
import { {{name}} } from '{{modulePath}}';
{{/each}}
{{#if authenticationModule}}
// @ts-ignore - no great way to install types from subpackage
const promiseAny = require('promise.any');
{{/if}}
{{#if iocModule}}
import { iocContainer } from '{{iocModule}}';
import { IocContainer, IocContainerFactory } from '@jeremydavidson/tsoa';
{{/if}}
import { APIGatewayProxyEvent, APIGatewayProxyStructuredResultV2, Context } from 'aws-lambda';
{{!--
TODO: We probably wont support file upload on lambda?
{{#if useFileUploads}}
const multer = require('multer');
const upload = multer();
{{/if}}
--}}

// WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file:
https://github.com/lukeautry/tsoa

const models: TsoaRoute.Models = {
{{#each models}}
"{{@key}}": {
{{#if enums}}
"dataType": "refEnum",
"enums": {{{json enums}}},
{{/if}}
{{#if properties}}
"dataType": "refObject",
"properties": {
{{#each properties}}
"{{@key}}": {{{json this}}},
{{/each}}
},
"additionalProperties": {{{json additionalProperties}}},
{{/if}}
{{#if type}}
"dataType": "refAlias",
"type": {{{json type}}},
{{/if}}
},
// WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file:
https://github.com/lukeautry/tsoa
{{/each}}
};
const validationService = new ValidationService(models);

// WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file:
https://github.com/lukeautry/tsoa

export function RegisterRoutes() {
// ###########################################################################################################
// NOTE: If you do not see routes for all of your controllers in this file, then you might not have informed tsoa of
where to look
// Please look into the "controllerPathGlobs" config option described in the readme: https://github.com/lukeautry/tsoa
// ###########################################################################################################
const handlers = {
{{#each controllers}}
{{#each actions}}
{{!--
TODO: Currently passing in the callback so we can catch error and return to API gateway, would be better to see if
someone has sent in the
the callback and then decide if we should invoke it or not
--}}
'{{uppercase method}} {{fullPath}}': {{#if ../../iocModule}}async {{/if}}function {{../name}}_{{name}}(event:
APIGatewayProxyEvent, context: Context, callback: any) {
const args = {
{{#each parameters}}
{{@key}}: {{{json this}}},
{{/each}}
};

// WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file:
https://github.com/lukeautry/tsoa

let validatedArgs: any[] = [];
try {
validatedArgs = getValidatedArgs(args, event);

{{#if ../../iocModule}}
const container: IocContainer = typeof iocContainer === 'function' ? (iocContainer as IocContainerFactory)(request) :
iocContainer;

const controller: any = await container.get<{{.. /name}}>({{../name}});
    if (typeof controller['setStatus'] === 'function') {
    controller.setStatus(undefined);
    }
    {{else}}
    const controller = new {{../name}}();
    {{/if}}

    const promise = controller.{{name}}.apply(controller, validatedArgs as any);
    return promiseHandler(controller, promise, {{successStatus}}, callback);
    } catch (err) {
    {{!--
    TODO: This callback isn't very smart, err might not be JSON
    and so we should hve safer default.

    By virtue of catching here, it is still 400 code, if message
    is not JSON we do not want to leak application logic
    :thinking:
    --}}
    console.log("Error on promiseHandler: " + err)
    return returnHandler(400, err, {})
    }
    },
    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file:
    https://github.com/lukeautry/tsoa
    {{/each}}
    {{/each}}
    }

    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file:
    https://github.com/lukeautry/tsoa

    function isController(object: any): object is Controller {
    return 'getHeaders' in object && 'getStatus' in object && 'setStatus' in object;
    }

    function promiseHandler(controllerObj: any, promise: any, successStatus: any, callback: any) {
    return Promise.resolve(promise)
    .then((data: any) => {
    console.log("promiseHandler data: " + JSON.stringify(data))
    let statusCode = successStatus;
    let headers;
    console.log(`isController(${JSON.stringify(controllerObj)}): ` + isController(controllerObj))
    if (isController(controllerObj)) {
    headers = controllerObj.getHeaders();
    statusCode = controllerObj.getStatus() || statusCode;
    }

    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file:
    https://github.com/lukeautry/tsoa
    console.log("promiseHandler calling returnHandler: " + (data))
    if (data != undefined) {
    return returnHandler(statusCode, data, headers)
    }
    })
    .catch((error) => {
    console.log("Error inside promiseHandler: " + error + ", json-error: " + JSON.stringify(error))
    let statusCode = 400;
    if (error.statusCode) {
    statusCode = error.statusCode;
    }
    return {
    statusCode,
    body: JSON.stringify({"error": error})
    }
    // callback(error)
    });
    }

    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file:
    https://github.com/lukeautry/tsoa

    function returnHandler(statusCode?: number, data?: any, headers: any = {}): APIGatewayProxyStructuredResultV2 {
    console.log("Calling returnHandler: " + statusCode + ", " + JSON.stringify(data))
    const response = {
    headers,
    statusCode: statusCode || 200,
    body: JSON.stringify(data)
    }
    return response;
    }

    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file:
    https://github.com/lukeautry/tsoa

    function getValidatedArgs(args: any, event: APIGatewayProxyEvent): any[] {

    const fieldErrors: FieldErrors = {};
    const values = Object.keys(args).map((key) => {
    const name = args[key].name;
    const input = args[key].in
    {{!--
    TODO: Parsing the JSON body should be a configuration
    choice
    --}}
    const parsedBody = event.body && JSON.parse(event.body)
    switch (input) {
    case 'request':
    return event;
    case 'query':
    return event.queryStringParameters && validationService.ValidateParam(args[key], event.queryStringParameters[name],
    name, fieldErrors, undefined, {{{json minimalSwaggerConfig}}});
    case 'path':
    return event.pathParameters && validationService.ValidateParam(args[key], event.pathParameters[name], name,
    fieldErrors, undefined, {{{json minimalSwaggerConfig}}});
    case 'header':
    return event.headers && validationService.ValidateParam(args[key], event.headers[name], name, fieldErrors,
    undefined, {{{json minimalSwaggerConfig}}});
    case 'body':
    return parsedBody && validationService.ValidateParam(args[key], parsedBody, name, fieldErrors, undefined, {{{json
    minimalSwaggerConfig}}});
    case 'res':
    return responder();
    {{!--
    TODO: Understand the body prop
    case 'body-prop':
    return validationService.ValidateParam(args[key], request.body[name], name, fieldErrors, 'body.', {{{json
    minimalSwaggerConfig}}});
    --}}
    {{!--
    TODO: Understand the form data

    case 'formData':
    if (args[key].dataType === 'file') {
    return validationService.ValidateParam(args[key], request.file, name, fieldErrors, undefined, {{{json
    minimalSwaggerConfig}}});
    } else if (args[key].dataType === 'array' && args[key].array.dataType === 'file') {
    return validationService.ValidateParam(args[key], request.files, name, fieldErrors, undefined, {{{json
    minimalSwaggerConfig}}});
    } else {
    return validationService.ValidateParam(args[key], request.body[name], name, fieldErrors, undefined, {{{json
    minimalSwaggerConfig}}});
    } --}}
    }
    });

    if (Object.keys(fieldErrors).length > 0) {
    throw new ValidateError(fieldErrors, '');
    }
    return values;
    }

    // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this file:
    https://github.com/lukeautry/tsoa

    function responder(): TsoaResponse<HttpStatusCodeLiteral, unknown> {
        console.log("In responder")
        return function(status, data, headers) {
        console.log("In responder function: " + status + ", " + JSON.stringify(data))
        returnHandler(status, data, headers);
        };
        };

        return handlers

        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this
        file: https://github.com/lukeautry/tsoa
        }

        // WARNING: This file was auto-generated with tsoa. Please do not modify it. Re-run tsoa to re-generate this
        file: https://github.com/lukeautry/tsoa